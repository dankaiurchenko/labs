package com.bogdanaiurchienko.analyzer;

import com.bogdanaiurchienko.output.Printer;
import com.bogdanaiurchienko.output.PrinterException;
import com.bogdanaiurchienko.sorters.AbstractSorter;
import com.bogdanaiurchienko.sorters.SorterException;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map.Entry;

/**
  * <p>Scans all sorter classes, which must extend AbstractSorter
  * {@link com.bogdanaiurchienko.sorters.AbstractSorter}.</p>
  * <p>Measures the time of sorting process in ms, of different types of arrays, which are generated by
  * static functions of Filler class. {@link com.bogdanaiurchienko.fillers.Filler}</p>
  * <p>Uses Printer class {@link com.bogdanaiurchienko.output.Printer} output the results.</p>
  * <p>Sorter classes and filler methods are found automatically by ClassScanner
  * {@link com.bogdanaiurchienko.analyzer.ClassScanner}</p>
 * @author Bogdana Iurchienko
 */
@SuppressWarnings("WeakerAccess")
public class Analyzer {

  private final int[] arrayLength;
  private final ClassScanner classScanner = new ClassScanner();
  private final ArrayInitializer arrayInitializer = new ArrayInitializer();


  /**
   *
   * @param arrayLength int array that contains number of elements in each array to sort
   */
  public Analyzer(int[] arrayLength) throws AnalyzerException {
    if(arrayLength.length < 1) {
      throw new AnalyzerException(" Invalid array lengths to analyze");
    }
    this.arrayLength = arrayLength;
  }

  int[] getArrayLength() {
    return arrayLength;
  }

  /**
   * Finds all sorter classes in pack, initialises instances of them and calls the
   * {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllSorters(int[], HashMap)}
   * for array of arrays (the sizes of {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength})
   * generated by every single filler method, found in Filler class.
   * Prints the result of analyzing every single array filler type
   * in separate file using {@link com.bogdanaiurchienko.output.Printer}
   * @see ArrayInitializer
   * @see ClassScanner#getFillerMethodsWithAnnotation()
   * @throws AnalyzerException in case of problems while analyzing
   * @throws PrinterException in case of problems with output
   * @param pack String name of package, where sorter classes are to be found
   */
  public void analyzeAllArrayTypes(String pack) throws AnalyzerException, PrinterException, SorterException {
    LinkedHashMap<String, AbstractSorter> sorters = classScanner.initSorters(pack);
    HashMap<String, HashMap<String, HashMap<String, Long>>> resultsForAllArrayTypes = new HashMap<>();
    for(Entry<String, Method> method: classScanner.getFillerMethodsWithAnnotation()){
      int[][] arrays = arrayInitializer.initArrays(method.getValue(), arrayLength);
      resultsForAllArrayTypes.put(method.getKey(), analyzeAllArrayLength(sorters, arrays));
    }
    new Printer(resultsForAllArrayTypes, classScanner.getSorterNames(), arrayLength).print();
  }

  /**
   * Calls {@code analyzeSort(AbstractSorter sorter, int[] arrayToSort)} for every array in allArrays param.
   * <p>Creates {@code HashMap<Integer, Long> allArrayLengthSortTimeMS} which contains sort time in ms for every array sorted with
   * {@code sorter} sorter class.</p>
   *
   * @param sorters sorter class, that extends {@link com.bogdanaiurchienko.sorters.AbstractSorter} to be tested
   * @param allArrays arrays to be sorted by {@link @param sorter}
   * @return results of sort time measurement for every array size by {@link @param sorter}
   */
  private HashMap<String, HashMap<String, Long>> analyzeAllArrayLength(HashMap<String, AbstractSorter> sorters,
                                                                       int[][] allArrays) throws SorterException {
    HashMap<String, HashMap<String, Long>> allArrayLengthSortTimeMS = new HashMap<>();
    for (int j = 0; j < allArrays.length; j++) {
      allArrayLengthSortTimeMS.put(String.valueOf(arrayLength[j]),
              analyzeAllSorters(Arrays.copyOf(allArrays[j], arrayLength[j]), sorters));
    }
    return allArrayLengthSortTimeMS;
  }


  /**
    * Calls {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllArrayLength(HashMap, int[][])}
    * for every sorter in <b>sorters<b/> param.
    * Creates {@code LinkedHashMap<String, HashMap<Integer, Long>> allSortersSortTimeMS}, that contains results
    * of sort time measurement for every array size for every sorter.
    *
    * @param array array of defined size {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @param sorters array of sorters that are to be tested
    * @return results of sort time measurement for every array size for every sorter
    */
  private HashMap<String, Long> analyzeAllSorters(int[] array, HashMap<String, AbstractSorter> sorters) throws SorterException {
    HashMap<String, Long> allSortersSortTimeMS = new HashMap<>();
    for (Entry<String, AbstractSorter> sorter : sorters.entrySet()) {
      allSortersSortTimeMS.put(sorter.getKey(), analyzeSort(sorter.getValue(), array));
    }
    return allSortersSortTimeMS;
  }


   /**
    * Measures sort time of <b>arrayToSort</b> by <b>sorter</b> object in ms .
    *
    * @param sorter sorter class to be tested
    * @param arrayToSort  array of one particular size from {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @return sort time in ms
    */
  private long analyzeSort(AbstractSorter sorter, int[] arrayToSort) throws SorterException {
    long before = System.currentTimeMillis();
    sorter.sort(arrayToSort);
    long after = System.currentTimeMillis();
    return after - before;
  }


}
