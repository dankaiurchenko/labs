package com.bogdanaiurchienko.analyzer;

import com.bogdanaiurchienko.output.Printer;
import com.bogdanaiurchienko.sorters.AbstractSorter;

import java.lang.reflect.Method;
import java.util.*;
import java.util.Map.Entry;

/**
  * <p>Scans all sorter classes, which must extend AbstractSorter
  * {@link com.bogdanaiurchienko.sorters.AbstractSorter}.</p>
  * <p>Measures the time of sorting process in ms, of different types of arrays, which are generated by
  * static functions of Filler class. {@link com.bogdanaiurchienko.fillers.Filler}</p>
  * <p>Uses Printer class {@link com.bogdanaiurchienko.output.Printer} output the results.</p>
  * <p>Sorter classes and filler methods are found automatically by ClassScanner
  * {@link com.bogdanaiurchienko.analyzer.ClassScanner}</p>
 * @author Bogdana Iurchienko
 */
@SuppressWarnings("WeakerAccess")
public class Analyzer {

  private final int[] arrayLength;
  private final ClassScanner classScanner = new ClassScanner();
  private final ArrayInitializer arrayInitializer = new ArrayInitializer();

  /**
   *
   * @param arrayLength int array that contains number of elements in each array to sort
   */
  public Analyzer(int[] arrayLength) {
    this.arrayLength = arrayLength;
  }

  int[] getArrayLength() {
    return arrayLength;
  }

  /**
   * Finds all sorter classes in pack, initialises instances of them and calls the
   * {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllSorters(int[][], LinkedHashMap)}
   * for array of arrays (the sizes of {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength})
   * generated by every single filler method, found in Filler class.
   * Prints the result of analyzing every single array filler type
   * in separate file using {@link com.bogdanaiurchienko.output.Printer}
   * @see ArrayInitializer
   * @see ClassScanner#getFillerMethodsWithAnnotation()
   * @throws AnalyzerException in case of problems while analyzing
   * @param pack String name of package, where sorter classes are to be found
   */
  public void analyzeAllArrayTypes(String pack) throws AnalyzerException {
    LinkedHashMap<String, AbstractSorter> sorters = classScanner.initSorters(pack);
    for(Entry<String, Method> method: classScanner.getFillerMethodsWithAnnotation()){
      int[][] arrays = arrayInitializer.initArrays(method.getValue(), arrayLength);
      Printer.print(method.getKey(), arrayLength, analyzeAllSorters(arrays, sorters));
    }
  }

   /**
    * Calls {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllArrayLength(AbstractSorter, int[][])}
    * for every sorter in <b>sorters<b/> param.
    * Creates {@code LinkedHashMap<String, HashMap<Integer, Long>> allSortersSortTimeMS}, that contains results
    * of sort time measurement for every array size for every sorter.
    *
    * @param allArrays arrays of defined sizes {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @param sorters array of sorters that are to be tested
    * @return results of sort time measurement for every array size for every sorter
    */
  private HashMap<String, HashMap<Integer, Long>> analyzeAllSorters(int[][] allArrays, LinkedHashMap<String, AbstractSorter> sorters){
    LinkedHashMap<String, HashMap<Integer, Long>> allSortersSortTimeMS = new LinkedHashMap<>();
    for (Entry<String, AbstractSorter> sorter : sorters.entrySet()) {
      allSortersSortTimeMS.put(sorter.getKey(), analyzeAllArrayLength(sorter.getValue(), allArrays));
    }
    return allSortersSortTimeMS;
  }

   /**
    * Calls {@code analyzeSort(AbstractSorter sorter, int[] arrayToSort)} for every array in allArrays param.
    * <p>Creates {@code HashMap<Integer, Long> allArrayLengthSortTimeMS} which contains sort time in ms for every array sorted with
    * {@code sorter} sorter class.</p>
    *
    * @param sorter sorter class, that extends {@link com.bogdanaiurchienko.sorters.AbstractSorter} to be tested
    * @param allArrays arrays to be sorted by {@link @param sorter}
    * @return results of sort time measurement for every array size by {@link @param sorter}
    */
  private HashMap<Integer, Long> analyzeAllArrayLength(AbstractSorter sorter, int[][] allArrays) {
    HashMap<Integer, Long> allArrayLengthSortTimeMS = new HashMap<>();
    for (int j = 0; j < allArrays.length; j++) {
      allArrayLengthSortTimeMS.put(arrayLength[j], analyzeSort(sorter, Arrays.copyOf(allArrays[j], arrayLength[j])));
    }
    return allArrayLengthSortTimeMS;
  }

   /**
    * Measures sort time of <b>arrayToSort</b> by <b>sorter</b> object in ms .
    *
    * @param sorter sorter class to be tested
    * @param arrayToSort  array of one particular size from {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @return sort time in ms
    */
  private long analyzeSort(AbstractSorter sorter, int[] arrayToSort) {
    long before = System.currentTimeMillis();
    sorter.sort(arrayToSort);
    long after = System.currentTimeMillis();
    return after - before;
  }


}
