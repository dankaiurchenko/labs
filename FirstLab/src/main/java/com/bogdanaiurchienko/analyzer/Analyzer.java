package com.bogdanaiurchienko.analyzer;

import com.bogdanaiurchienko.output.Printer;
import com.bogdanaiurchienko.sorters.AbstractSorter;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map.Entry;
 /**
  * <p>Scans all sorter classes, which must extend AbstracSorter
  * {@link com.bogdanaiurchienko.sorters.AbstractSorter}.</p>
  * <p>Measures the time of sorting process in ms, of different types of arrays, which are generated by
  * static functions of Filler class. {@link com.bogdanaiurchienko.fillers.Filler}</p>
  * <p>Uses Printer class {@link com.bogdanaiurchienko.output.Printer} output the results.</p>
  * <p>Sorter classes and filler methods are found automatically by ClassScanner
  * {@link com.bogdanaiurchienko.analyzer.ClassScanner}</p>
 * @author Bogdana Iurchienko
 */
public class Analyzer {

  private int[] arrayLength;
  private ClassScanner classScanner = new ClassScanner();
  private ArrayInitializer arrayInitializer = new ArrayInitializer();

  /**
   *
   * @param arrayLength int array that contains number of elements in each array to sort
   */
  public Analyzer(int[] arrayLength) {
    this.arrayLength = arrayLength;
  }

  /**
   * Finds all sorter classes in pack, initialises instances of them and calls the
   * {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllSorters(int[][], LinkedHashMap)}
   * for array of arrays (the sizes of {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength})
   * generated by every single filler method, found in Filler class.
   * Prints the result of analyzing every single array filler type
   * in separate file using {@link com.bogdanaiurchienko.output.Printer}
   * @see ArrayInitializer
   * @see ClassScanner#getFillerMethodsWithAnnotation()
   *
   * @param pack String name of package, where sorter classes are to be found
   */
  public void analyzeAllArrayTypes(String pack) {
    LinkedHashMap<String, AbstractSorter> sorters = classScanner.initSorters(pack);
    for(Entry<String, Method> method: classScanner.getFillerMethodsWithAnnotation()){
      int[][] arrays = arrayInitializer.initArrays(method.getValue());
      Printer.print(method.getKey(), arrayLength, analyzeAllSorters(arrays, sorters));
    }
  }

   /**
    * Calls {@link com.bogdanaiurchienko.analyzer.Analyzer#analyzeAllArrayLength(AbstractSorter, int[][])}
    * for every sorter in <b>sorters<b/> param.
    * Creates {@code LinkedHashMap<String, HashMap<Integer, Long>> allSortersSortTimeMS}, that contains results
    * of sort time measurement for every array size for every sorter.
    *
    * @param allArrays arrays of defined sizes {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @param sorters array of sorters that are to be tested
    * @return results of sort time measurement for every array size for every sorter
    */
  private HashMap<String, HashMap<Integer, Long>> analyzeAllSorters(int[][] allArrays, LinkedHashMap<String, AbstractSorter> sorters){
    LinkedHashMap<String, HashMap<Integer, Long>> allSortersSortTimeMS = new LinkedHashMap<>();
    for (Entry<String, AbstractSorter> sorter : sorters.entrySet()) {
      allSortersSortTimeMS.put(sorter.getKey(), analyzeAllArrayLength(sorter.getValue(), allArrays));
    }
    return allSortersSortTimeMS;
  }

   /**
    * Calls {@code analyzeSort(AbstractSorter sorter, int[] arrayToSort)} for every array in allArrays param.
    * <p>Creates {@code HashMap<Integer, Long> allArrayLengthSortTimeMS} which contains sort time in ms for every array sorted with
    * {@code sorter} sorter class.</p>
    *
    * @param sorter sorter class, that extends {@link com.bogdanaiurchienko.sorters.AbstractSorter} to be tested
    * @param allArrays arrays to be sorted by {@link @param sorter}
    * @return results of sort time measurement for every array size by {@link @param sorter}
    */
  private HashMap<Integer, Long> analyzeAllArrayLength(AbstractSorter sorter, int[][] allArrays) {
    HashMap<Integer, Long> allArrayLengthSortTimeMS = new HashMap<>();
    for (int j = 0; j < allArrays.length; j++) {
      allArrayLengthSortTimeMS.put(arrayLength[j], analyzeSort(sorter, Arrays.copyOf(allArrays[j], arrayLength[j])));
    }
    return allArrayLengthSortTimeMS;
  }

   /**
    * Measures sort time of <b>arrayToSort</b> by <b>sorter</b> object in ms .
    *
    * @param sorter sorter class to be tested
    * @param arrayToSort  array of one particular size from {@link com.bogdanaiurchienko.analyzer.Analyzer#arrayLength}
    * @return sort time in ms
    */
  private long analyzeSort(AbstractSorter sorter, int[] arrayToSort) {
    long before = System.currentTimeMillis();
    sorter.sort(arrayToSort);
    long after = System.currentTimeMillis();
    return after - before;
  }

   /**
    * Class that invokes filler methods found with <b>ClassScanner</b>
    * in {@link com.bogdanaiurchienko.fillers.Filler}
    * and converts the result into int[][]
    * @see ClassScanner#getFillerMethodsWithAnnotation()
    */

  private class ArrayInitializer{

     /**
      * Calls <b>method</b> for every value in {@link Analyzer#arrayLength} and adds to return 2-dimensional array.
      *
      * @param method filler method from {@link com.bogdanaiurchienko.fillers.Filler}
      * @return 2-dimensional array of int with arrays of each size
      */
    private int[][] initArrays(Method method) {
      int[][] arrays = new int[arrayLength.length][];
      for(int i = 0; i < arrayLength.length; i++){
        try {
          arrays[i] = toPrimitive(toInteger(unpack(method.invoke(null, arrayLength[i], arrayLength[i] * 2))));
        } catch (IllegalAccessException | InvocationTargetException e) {
          e.printStackTrace();
        }
      }
      return arrays;
    }

     /**
      * Converts Integer[] into int[]
      * @see ArrayInitializer#toInteger(Object[])
      * @param IntegerArray array of Integer
      * @return {@link @param IntegerArray} converted into int[]
      */
    private int[] toPrimitive(Integer[] IntegerArray) {

      int[] result = new int[IntegerArray.length];
      for (int i = 0; i < IntegerArray.length; i++) {
        result[i] = IntegerArray[i];
      }
      return result;
    }

     /**
      * Converts array of objects into Integer array
      * @see ArrayInitializer#unpack(Object)
      * @see ArrayInitializer#toPrimitive(Integer[])
      * @param array array of Objects to be converted
      * @return resulting Integer array
      */
    private Integer[] toInteger(Object[] array) {
      Integer[] integerArray = new Integer[array.length];
      int i = 0;
      for (Object a : array) {
        integerArray[i++] = (Integer) a;
      }
      return integerArray;
    }

     /**
      * Unpacks array of numbers represented as Object returned by reflective filler method invocation
      * @see ArrayInitializer#initArrays(Method)
      * @see ArrayInitializer#toInteger(Object[])
      * @param array array of numbers represented as an instance of Object
      * @return array of Objects
      */
    private Object[] unpack(Object array) {
      Object[] array2 = new Object[Array.getLength(array)];
      for (int i = 0; i < array2.length; i++)
        array2[i] = Array.get(array, i);
      return toInteger(array2);
    }

  }

}
